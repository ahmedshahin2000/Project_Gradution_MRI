# -*- coding: utf-8 -*-
"""zeko.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yY0GaRlf3fsUjrvpz__QQRZP_5ahzK9z
"""
import os
os.environ['KAGGLE_USERNAME'] = 'thedesertm'
os.environ['KAGGLE_KEY'] = '08da85d8244fde4552d51ab1f013319c'

# ! kaggle datasets download -d navoneel/brain-mri-images-for-brain-tumor-detection

# ! unzip /content/brain-mri-images-for-brain-tumor-detection.zip

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import matplotlib.pyplot as plt
import seaborn as sns
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from PIL import Image
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder

yes_data = []
no_data = []
paths = []
labels = []
import os
for dirname, _, filenames in os.walk(r'/content/brain_tumor_dataset/yes'):
    for filename in filenames:
        if '.jpg' in filename:
            paths.append(os.path.join(dirname, filename))

encoder = OneHotEncoder()
encoder.fit([[0], [1]])
for path in paths:
    image = Image.open(path)
    image = image.resize((128,128))
    image= np.array(image)
    if image.shape == (128,128,3):
        yes_data.append(np.array(image))
        labels.append(encoder.transform([[0]]).toarray())
labels[0]

more_paths = []
for dirname, _, filenames in os.walk(r'/content/brain_tumor_dataset/no'):
    for filename in filenames:
        if '.jpg' in filename:
            more_paths.append(os.path.join(dirname, filename))

for path in more_paths:
    image = Image.open(path)
    image = image.resize((128,128))
    image = np.array(image)
    if image.shape == (128,128,3):
        yes_data.append(np.array(image))
        labels.append(encoder.transform([[1]]).toarray())

yes_data = np.array(yes_data)
yes_data.shape

labels = np.array(labels)
labels = labels.reshape(139,2)
labels.shape

np.set_printoptions(linewidth = 200)
plt.imshow(yes_data[0])
print(yes_data[0])
print(labels[0])

train_data, test_data, train_labels, test_labels = train_test_split(yes_data, labels, random_state = 3, shuffle = True)

train_data.shape, test_data.shape, train_labels.shape, test_labels.shape

train_data = train_data /255.0
test_data = test_data/255.0

from tensorflow.keras.layers import Input
from tensorflow.keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten
from tensorflow.keras.models import Model
from tensorflow.keras.layers import BatchNormalization
input = Input(shape = (128,128,3))
x = Conv2D(16, (3,3), activation = 'relu')(input)
x = BatchNormalization()(x)
x = MaxPooling2D(2,2)(x)
x = Conv2D(32, (3,3), activation = 'relu')(x)
x = MaxPooling2D(2,2)(x)
x = Flatten()(x)
x = BatchNormalization()(x)
x = Dense(124, activation = 'relu')(x)
x = Dropout(0.27)(x)
x = Dense(124, activation = 'relu')(x)
output = Dense(2, activation = 'softmax')(x)
model = Model(inputs = input, outputs = output)
model.summary()

from tensorflow.keras.optimizers import RMSprop,Adam

model.compile(loss = 'categorical_crossentropy', optimizer = RMSprop(lr = 0.001), metrics = ["accuracy"])

lr_schedule = tf.keras.callbacks.LearningRateScheduler(lambda epoch: 1e-8*10**(epoch / 20))

from keras.callbacks import EarlyStopping, ModelCheckpoint
en = EarlyStopping(monitor='val_loss', patience=10, verbose=1)
mc = ModelCheckpoint(monitor='val_loss', filepath='best_model.hdf5',verbose=1, save_best_only=True)
history = model.fit(train_data, train_labels, epochs = 75, callbacks = [lr_schedule,en,mc],validation_data = (test_data, test_labels))

plt.figure(figsize = (12,7))
plt.plot(history.history['accuracy'], label = 'train accuracy')
plt.plot(history.history['val_accuracy'], label = 'validation accuracy')
plt.title("train accuracy vs validation accuracy")
plt.legend()
plt.show()

plt.figure(figsize = (12,7))

plt.plot(history.history['loss'], label = 'train loss')
plt.plot(history.history['val_loss'], label = 'validation loss')
plt.legend()
plt.title("train vs validation loss")
plt.show()

def tumor(number):
    if number == 0:
        return "Not a tumor"
    else:
        return "a tumor"

img = Image.open(r"/content/yes/Y244.JPG")
x = np.array(img.resize((128,128)))
x = x.reshape(1, 128, 128, 3)
result = model.predict([x])
classification = np.where(result == np.amax(result))[1][0]
print(str(result[0][classification]*100) + '% Confidence This Is ' + tumor(classification))
plt.imshow(img)

img2 = Image.open(r"/content/no/no 97.jpg")
y = np.array(img2.resize((128,128)))
y = y.reshape(1, 128, 128, 3)
result2 = model.predict([y])
ind = 0
classification2 = 0
import numpy as np
for result in result2:
    result = result.tolist()
    print(result)
    if result[0] > result[1]:
        classification = 1
        ind = 0
    else:
        classification = 0
        ind = 1
#classification2 = np.where(result2 == np.amax(result2))[1][0]
print(str(result2[0][ind]*100) + '% Confidence This Is ' + tumor(classification2))
plt.imshow(img2)